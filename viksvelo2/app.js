$(function(){

// START FUNCTION
  // COUNTDOWN TIMER
  // MAKE INPUTS LIVE
            // INPUTS - KEYPRESS (SPACEBAR)
            // OUTPUTS - ANIMATION THEN RUN ALL GAME FUNCTIONS

            var winner = null;
            // var playing = false;
            var cadCount;
            var posCalc1;
            var posCalc2;
            var win;

function start(){
  // playing = true;

  // cadenceP1 = 0;
  // cadenceP2 = 0;
  // flipAS = false;
  // flipKL = false
  // speedP1 = 0;
  // speedP2 = 0;
  // angleP1 = -90;
  // angleP2 = 90;
  // rad = 125;
  // // startXPosP1 = 660;
  // // startYPosP1 = 320;
  // // startXPosP2 = 720;
  // // startYPosP2 = 320;
  // xPosP1 = 660;
  // yPosP1 = 320;
  // xPosP2 = 720;
  // yPosP2 = 320;

  $("#btstart").click(function(){
    $("#track").append("<h3>3</h3>");
    setTimeout(function(){
      $("#track h3").remove("#track h3");
      $("#track").append("<h3>2</h3>");
    }, 1000);
    setTimeout(function(){
      $("#track h3").remove("#track h3");
      $("#track").append("<h3>1</h3>");
    }, 2000);
    setTimeout(function(){
      $("#track h3").remove("#track h3");
      $("#track").append("<h3>GO!</h3>");
    }, 3000);
    setTimeout(function(){
      $("#track h3").remove("#track h3");
    }, 3500);
// Start interval loops to measure speed and position here once working!
    setTimeout (function(){
       cadCount = setInterval(cadenceCounter, 1000);
       posCalc1 = setInterval(positionCalcP1, 50);
       posCalc2 = setInterval(positionCalcP2, 50);
       win = setInterval(catchCalc, 50);
    }, 3500);

    console.log(winner);
        // console.log('angleP1:'+angleP1, 'angleP2:'+angleP2);

  })
};

function stop() {
  clearInterval(cadCount);
  clearInterval(posCalc1);
  clearInterval(posCalc2);
  clearInterval(win);
  // playing = false;
  cadenceP1 = 0;
  cadenceP2 = 0;
  flipAS = false;
  flipKL = false
  speedP1 = 0;
  speedP2 = 0;
  angleP1 = -90;
  angleP2 = 90;
  rad = 125;
  // startXPosP1 = 660;
  // startYPosP1 = 320;
  // startXPosP2 = 720;
  // startYPosP2 = 320;
  xPosP1 = 660;
  yPosP1 = 320;
  xPosP2 = 720;
  yPosP2 = 320;


}

start();
// FUNCTION TO MEASURE SPEED OF CYCLIST

  // DISTANCE MOVED OVER TIME (SPEED) IS GENERATED BY THE FREQUENCY OF ALTERNATE BUTTON PRESSES
  // TESTING NEEDED TO FIND USER AVERAGE KEY ENTRY SPEEDS
  // DISTANCE TRAVELLED IS MEASRED BY COUNTING THE NUMBER OF PAIRED PRESSES IN .5 SECONDS WITH A .1 SECOND DELAY (TO SIMULATE ACCELLERATION - ALSO SOME SMOOTHING OF ACCELLERATION AND DECELLERATION?)
  // EG, IF ON START PLAYER ONE PRESSES THE KEYS (A,S,A,S...) 10 TIMES IN THE FIRST .5 SECONDS THEY WILL MOVE 20 UNITS AROUND THE TRACK BUT ONLY AFTER A .1 SECOND DELAY
            //INPUTS - PLAYER KEY PRESSES P1(A,S) P2(K,L)
            // OUTPUTS - 'SPEED' - NUMERICAL VARIABLE
var cadenceP1 = 0;
var cadenceP2 = 0;
var flipAS = false;
var flipKL = false


var speedP1 = 0;
var speedP2 = 0;



$(window).keypress(function(e){
  if ((e.which) === 97 ||(e.which) === 65){
    if (flipAS == false){
      // cadenceP1 ++;
      flipAS = !flipAS;
    }
  } else if ((e.which) === 115 ||(e.which) === 83){
        if (flipAS == true){
        cadenceP1 ++;
        flipAS = !flipAS;
      }
    }
  });
$(window).keypress(function(e){
  if ((e.which) === 75 ||(e.which) === 107){
    if (flipKL == false){
      // cadenceP2 ++;
      flipKL = !flipKL;
    }
  } else if ((e.which) === 76 ||(e.which) === 108){
        if (flipKL == true){
        cadenceP2 ++;
        flipKL = !flipKL;
      }
    }
  });

function cadenceCounter(){ 
  speedP1 = cadenceP1/3;
  speedP2 = cadenceP2/3;
  cadenceP1 = 0;
  cadenceP2 = 0;
  // console.log("speed" , speed);

};

 // window.setInterval(cadenceCounter, 1000);
// console.log("distanceP1:"+distanceP1);

// Need to create a distanceTravelled variable that increments speedp1/speedp2. Winner will have travelled greater distance.
// will this improve the rotation too?



// initialise listener on the window? only triggered by key A
//   When A is pressed: start Timer (0.5s)
//     + switch listener onto key S
//       When S is pressed register add 1 to cadence
//       + switch listener onto key A
//     Repeat until timer ends
//     Assign cadence as speedP1
//     reset Timer and cadence
//     disable with CATCH function


// FUNCTION TO CALCULATE POSITION OF A CYCLIST

  // POSITI0N IS MEASURED ALONG A CURVE GENERATED BY A SUPER ELLIPSE (http://www.procato.com/superellipse/ - http://mathworld.wolfram.com/Superellipse.html)

  // Circle equation (x-a)2 + (y-b)2 = r2
  // POSITION IS GENERATED EVERY .1 SECONDS BY THE SPEED GENERATED IN THE LAST .5 SECOND PERIOD
            // INPUT - PLAYER 'SPEED' NUMERICAL VARIABLE GENERATED BY SPEED FUNCTION
            // OUTPUT - PLAYER POSITION VALUE (AS CALCULATED ALONG THE OVAL) - POSITION TURNED INTO ANIMATED SPRITE


function degsToRads(angleDegs){
  angleRads = (angleDegs*Math.PI)/180;
  // console.log(angleRads);
  return angleRads;
}


var angleP1 = -90;
var angleP2 = 90;
var rad = 125;
var startXPosP1 = 660;
var startYPosP1 = 320;
var startXPosP2 = 720;
var startYPosP2 = 320;


function positionCalcP1 (){
  
  angleP1 += speedP1;
  spriteAngleP1 = angleP1 - 270;
  // BROKEN SUPER ELLIPSE
  // var cosAngle = Math.cos(degsToRads(angleP1));
  // var sinAngle = Math.sin(degsToRads(angleP1));
  // var xPosP1 = startXPosP1 + (200 * (Math.pow(cosAngle,(3/2))));
  // var yPosP1 = startYPosP1 + (200 * (Math.pow(sinAngle,(3/2))));
// ellipse version
  xPosP1 = (startXPosP1 + (500 * (Math.cos(degsToRads(angleP1)))));
  yPosP1 = (startYPosP1 + (130 * (Math.sin(degsToRads(angleP1)))));
  // console.log("anglep1:"+angleP1, "spriteAnglep1:"+spriteAngleP1);
  // console.log("x:"+xPosP1, "y:"+yPosP1);
  $("#sprite1").css({"left":xPosP1, "top":yPosP1});
  $("#sprite1").css({transform:'rotate(' + spriteAngleP1 + 'deg)'});
  return angleP1;
};


function positionCalcP2 (){
  
  angleP2 += speedP2;
  spriteAngleP2 = angleP2 + 270;
  // BROKEN SUPER ELLIPSE
  // var cosAngle = Math.cos(degsToRads(angle));
  // var sinAngle = Math.sin(degsToRads(angle));
  // var xPosP1 = startXPosP1 + (650 * (Math.pow(cosAngle),(2/2.5)));
  // var yPosP1 = startYPosP1 + (200 * (Math.pow(sinAngle),(2/2.5)));
// circle version
  xPosP2 = (startXPosP2 + (500 * (Math.cos(degsToRads(angleP2)))));
  yPosP2 = (startYPosP2 + (130 * (Math.sin(degsToRads(angleP2)))));
  // console.log("anglep2:"+angleP2, "spriteAnglep2:"+spriteAngleP2);
  // console.log("x:"+xPosP2, "y:"+yPosP2);
  $("#sprite2").css({"left":xPosP2, "top":yPosP2});
  $("#sprite2").css({transform:'rotate(' + spriteAngleP2 + 'deg)'});
  return angleP2;
};


// Super ellipse
// x = acos^(2/r)t 
// 
// y = bsin^(2/r)t.


// work out position of circle centre (a,b) from top left of screen?
// a = 720px (1440px/2)
// b = 330px (250px+80px)
// rad = 125px
// start position vertical = b-rad = 205px
// start position horizontal = a - (width/2) = 712px

// a + (rad * Math.cos angle) = x
// b + (rad * Math.sin angle) = y

// FUNCTION TO CALCULATE CATCH
  // IF/ELSE FUNCTION TAKING CYLISTS POSITION AND IF PLAYER 1 IS WITHIN X DISTANCE OF PLAYER 2 THEY WIN (AND VICE VERSA)
            // INPUT - PLAYER POSITION NUMERICAL VARIABLE GENERATED BY POSITION FUNCTION
            // OUTPUT - GAME STOPS AND APPROPRIATE WINNER ANIMATION IS RETURNED SCOREBOARD IS UPDATED WITH WIN COUNT

function catchCalc(){
  if (((angleP2 - angleP1) <= 10) && (angleP1 >= 0)){
    // console.log("Player 1 is the winner!");
    // console.log(angleP1 - angleP2);
    $("#track").append("<h3>RED WINS</h3>"); //P1
    winner = "p1";
    scoreboard ("p1");
    stop();
  } else if ((angleP2 - angleP1) >= 350){
    // console.log("Player 2 is the winner!");
    $("#track").append("<h3>BLUE WINS</h3>"); //P2
    winner = "p2";
    scoreboard ("p2");
    stop();
  }
}


// FUNCTION TO UPDATE SCORE BOARD
  // TAKES PLAYER WINS AND INCREMENTS BASED ON THE NUMBERS FOR EACH
            // INPUT - PLAYER WINS BASED ON CATCH FUNCTION
            // OUTPUT - NUMBERS CHANGE ON SCOREBOARD

var scoreP1 = 0;
var scoreP2 = 0;

function scoreboard (winner){
  if (winner === "p1") {
    scoreP1 ++;
    $("#p1Score span").remove("#p1Score span"); 
    $("#p1Score").append("<span>"+scoreP1+"</span>"); 
  } else if (winner === "p2") {
  scoreP2 ++;
  $("#p2Score span").remove("#p2Score span"); 
  $("#p2Score").append("<span>"+scoreP2+"</span>"); 

  }
}


// FUNCTION TO RESET
  // USES THE START BUTTON TO RESTART THE GAME
            // INPUT - KEYPRESS (SPACEBAR)
            // OUTPUTS - RUNS START FUNCTION
// not needed? scoreboard function resets to zero anyway?



  // Start and countdown function
  //   Timer animation
  //   Make buttons ready for key press
  // Measure cyclist speed function
  //  Take input from keys
  //  Calculate speed based on frequency of alternation
  // Calculate cyclist position function
  //  Take speed and use it to travel a distance around track
  // Calculate catch function
  //  Calculate when both cyclists overlap on the track
  //  Calculate which has caught the other
  // Return win animation
  //  Count wins to scoreboard
  // Reset function
  // Clears scoreboard and triggers start
});