$(function(){

// START FUNCTION
  // COUNTDOWN TIMER
  // MAKE INPUTS LIVE
            // INPUTS - KEYPRESS (SPACEBAR)
            // OUTPUTS - ANIMATION THEN RUN ALL GAME FUNCTIONS

function start(){
  $("#btstart").click(function(){
    console.log("start clicked")
    $("#track").append("<h3>3</h3>");
    setTimeout(function(){
      $("#track h3").remove("#track h3");
      $("#track").append("<h3>2</h3>");
    }, 1000);
    setTimeout(function(){
      $("#track h3").remove("#track h3");
      $("#track").append("<h3>1</h3>");
    }, 2000);
    setTimeout(function(){
      $("#track h3").remove("#track h3");
      $("#track").append("<h3>GO!</h3>");
    }, 3000);
    setTimeout(function(){
      $("#track h3").remove("#track h3");
    }, 3500);
// Start interval loops to measure speed and position here once working!
  })
}

start();
// FUNCTION TO MEASURE SPEED OF CYCLIST

  // DISTANCE MOVED OVER TIME (SPEED) IS GENERATED BY THE FREQUENCY OF ALTERNATE BUTTON PRESSES
  // TESTING NEEDED TO FIND USER AVERAGE KEY ENTRY SPEEDS
  // DISTANCE TRAVELLED IS MEASRED BY COUNTING THE NUMBER OF PAIRED PRESSES IN .5 SECONDS WITH A .1 SECOND DELAY (TO SIMULATE ACCELLERATION - ALSO SOME SMOOTHING OF ACCELLERATION AND DECELLERATION?)
  // EG, IF ON START PLAYER ONE PRESSES THE KEYS (A,S,A,S...) 10 TIMES IN THE FIRST .5 SECONDS THEY WILL MOVE 20 UNITS AROUND THE TRACK BUT ONLY AFTER A .1 SECOND DELAY
            //INPUTS - PLAYER KEY PRESSES P1(A,S) P2(K,L)
            // OUTPUTS - 'SPEED' - NUMERICAL VARIABLE
var cadence = 0;
var flip = false;


var speed = 0;



$(window).keypress(function(e){
  if ((e.which) === 97 ||(e.which) === 65){
    if (flip == false){
      cadence ++;
      flip = !flip;
      // console.log("A", flip);
    }
  } else if ((e.which) === 83 ||(e.which) === 115){
        if (flip == true){
        cadence ++;
        flip = !flip;
        // console.log("S", flip);
      }
    }
  });

function cadenceCounter(){ 

  // distanceP1 = (cadence);
  speed = cadence/80;
  cadence = 0;
  console.log("speed" , speed);

  // positionCalc(distanceP1);
};

 window.setInterval(cadenceCounter, 1000);
// console.log("distanceP1:"+distanceP1);

// Need to create a distanceTravelled variable that increments speedp1/speedp2. Winner will have travelled greater distance.
// will this improve the rotation too?



// initialise listener on the window? only triggered by key A
//   When A is pressed: start Timer (0.5s)
//     + switch listener onto key S
//       When S is pressed register add 1 to cadence
//       + switch listener onto key A
//     Repeat until timer ends
//     Assign cadence as speedP1
//     reset Timer and cadence
//     disable with CATCH function


// FUNCTION TO CALCULATE POSITION OF A CYCLIST

  // POSITI0N IS MEASURED ALONG A CURVE GENERATED BY A SUPER ELLIPSE (http://www.procato.com/superellipse/ - http://mathworld.wolfram.com/Superellipse.html)

  // Circle equation (x-a)2 + (y-b)2 = r2
  // POSITION IS GENERATED EVERY .1 SECONDS BY THE SPEED GENERATED IN THE LAST .5 SECOND PERIOD
            // INPUT - PLAYER 'SPEED' NUMERICAL VARIABLE GENERATED BY SPEED FUNCTION
            // OUTPUT - PLAYER POSITION VALUE (AS CALCULATED ALONG THE OVAL) - POSITION TURNED INTO ANIMATED SPRITE


var angle = ((3*Math.PI)/2);
var rad = 125;
var startXPosP1 = 652;
var startYPosP1 = 320;



function positionCalc (){
  
  angle += speed;
  var spriteAngle = (60*angle)+90;

  var xPosP1 = (startXPosP1 + (rad * (Math.cos(angle))));
  var yPosP1 = (startYPosP1 + (rad * (Math.sin(angle))));
  console.log("angle:"+angle, "spriteAngle:"+spriteAngle);
  $("#sprite1").css({"left":xPosP1, "top":yPosP1});
  $("#sprite1").css({transform:'rotate(' + spriteAngle + 'deg)'});
  // $("#sprite1").css("transform: 'rotate('+(angle+90)+'deg'");
  // transform: 'rotate(' + -amount + 'deg)'
  // $("#sprite1").animate({"left":xPosP1, "top":yPosP1});
  // startXPosP1 = xPosP1;
  // startYPosP1 = yPosP1;
  // angle++;
};

// window.setTimeout(positionCalc, 500);
// window.setTimeout(positionCalc, 1000);
// window.setTimeout(positionCalc, 1500);
// window.setTimeout(positionCalc, 2000);


window.setInterval(positionCalc, (100));
// window.setInterval(positionCalc, (distanceP1));





// work out position of circle centre (a,b) from top left of screen?
// a = 720px (1440px/2)
// b = 330px (250px+80px)
// rad = 125px
// start position vertical = b-rad = 205px
// start position horizontal = a - (width/2) = 712px

// a + (rad * Math.cos angle) = x
// b + (rad * Math.sin angle) = y






// FUNCTION TO CALCULATE CATCH
  // IF/ELSE FUNCTION TAKING CYLISTS POSITION AND IF PLAYER 1 IS WITHIN X DISTANCE OF PLAYER 2 THEY WIN (AND VICE VERSA)
            // INPUT - PLAYER POSITION NUMERICAL VARIABLE GENERATED BY POSITION FUNCTION
            // OUTPUT - GAME STOPS AND APPROPRIATE WINNER ANIMATION IS RETURNED SCOREBOARD IS UPDATED WITH WIN COUNT
catchOverlap = 2; // 5px!? 2 px?


function catchCalc(){
  if (((p1xPos - p2xPos) < catchOverlap) && ((p1xPos - p2xPos) < catchOverlap)){
    if (distanceTravelledp1 > distanceTravelledp2){
      console.log("Player 1 is the winner!");
      $("#track").append("<h3>PLAYER 1 WINS</h3>");
      scoreboard ("p1");
    } else {
      console.log("Player 2 is the winner!");
      $("#track").append("<h3>PLAYER 2 WINS</h3>");
      scoreboard ("p2");    }
  }
}

// FUNCTION TO UPDATE SCORE BOARD
  // TAKES PLAYER WINS AND INCREMENTS BASED ON THE NUMBERS FOR EACH
            // INPUT - PLAYER WINS BASED ON CATCH FUNCTION
            // OUTPUT - NUMBERS CHANGE ON SCOREBOARD

var scoreP1 = 0;
var scoreP2 = 0;

function scoreboard (winner){
  if (winner === "p1") {
    scoreP1 ++;
  } else {
  scoreP2 ++;
  }
}


// FUNCTION TO RESET
  // USES THE START BUTTON TO RESTART THE GAME
            // INPUT - KEYPRESS (SPACEBAR)
            // OUTPUTS - RUNS START FUNCTION
// not needed? scoreboard function resets to zero anyway?



  // Start and countdown function
  //   Timer animation
  //   Make buttons ready for key press
  // Measure cyclist speed function
  //  Take input from keys
  //  Calculate speed based on frequency of alternation
  // Calculate cyclist position function
  //  Take speed and use it to travel a distance around track
  // Calculate catch function
  //  Calculate when both cyclists overlap on the track
  //  Calculate which has caught the other
  // Return win animation
  //  Count wins to scoreboard
  // Reset function
  // Clears scoreboard and triggers start
});